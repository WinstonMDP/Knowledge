\documentclass[oneside]{book}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage[left = 0.3\textwidth, right = 0.3\textwidth]{geometry}
\usepackage{parskip}
\usepackage[fleqn]{amsmath}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{textcomp}

\setlength{\parskip}{0.03\textheight}

\graphicspath{{images/}}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\newcommand{\meta}[1]{\text{<}#1\text{>}}
\newcommand{\set}[1]{\left\{#1\right\}}

\title{Логика}
\date{\today}
\author{Мы}

\begin{document}
    \maketitle

    \tableofcontents

    \chapter{Аксиоматический метод}
    Базовое понятие - это неопределяемое понятие.

    \section{}
    Зафиксировать базовые понятия.

    \section{}
    Зафиксировать аксиомы, связывающие понятия.

    \section{}
    Выводить следствия по правилам логики.

    \chapter{Теория множеств (ZFC)}
    \section{Базовые понятия}
    Принадлежность ($ x \in y $).

    \section{Аксиомы}
    \subsection{Равенства}
    \begin{flalign*}
        x = y \ \forall z \ \left(x \in z \iff y \in z\right)
    \end{flalign*}

    \subsection{Пары}
    \begin{flalign*}
        \exists \set{x, y}
    \end{flalign*}

    \subsection{Объединения}
    \begin{flalign*}
        \exists \cup x
    \end{flalign*}

    \subsection{Степени}
    \begin{flalign*}
        \exists \mathcal{P}(x)
    \end{flalign*}

    \subsection{Выделения}
    \begin{flalign*}
        \set{\left.x \in A \ \right| \ \varphi(x)}
    \end{flalign*}

    \subsection{Бесконечности}
    \begin{flalign*}
        \exists S - \text{индуктивное множество}
    \end{flalign*}

    \subsection{Выбора}
    \begin{flalign*}
        \varnothing \not\in S \
        \exists f \
        \begin{cases}
            f: S \rightarrow \cup S \\
            \forall s \in S \ f(s) \in s
        \end{cases}
    \end{flalign*}

    \subsection{Регулярности (фундированности)}
    Необязательная аксиома.
    \begin{flalign*}
        \exists y \in x \ \forall z \in x \ z \not\in y
    \end{flalign*}

    \subsection{Подстановки}
    Не знаю, что она означает. Необязательная аксиома.
    Аксиома выделения - это часть данной аксиомы.
    \begin{flalign*}
        \forall x \ \exists! y \ \varphi(x, y)
        \implies
        \forall X \ \exists z \ \forall u \
        \left(u \in z \iff \exists x \in X \ \varphi(x, u)\right)
    \end{flalign*}

    \section{Определения}
    Класс $ = \set{x \ \left| \ \varphi(x)\right.} $.
    Не все классы являются множествами. Все множества являются классами.
    \begin{flalign*}
        &x = y \iff \left(z \in x \iff z \in y\right) \\
        &y = \set{\ldots, x, \ldots} \iff x \in y \\
        &x \subseteq y \iff \forall z \in x \ z \in y \\
        &x \subsetneq y
        \iff
        \begin{cases}
            x \neq y \\
            x \subseteq y
        \end{cases} \\
        &\varnothing - \text{пустое множество} \\
        &x \not\in \varnothing \\
        &y \in \mathcal{P}(x) \iff y \subseteq x \\
        &y \in \cup x
        \iff
        \exists z
        \begin{cases}
            z \in x \\
            y \in z
        \end{cases} \\
        &x - \text{транзитивное множество} \iff \cup x \subseteq x \\
        &\cap x = \set{y \in \cup x \mid z \in x \ y \in z} \\
        &a \cup b = \cup\set{a, b} \\
        &a \cap b = \set{x \in a \mid x \in b} \\
        &a \setminus b = \set{x \in a \mid x \not\in b} \\
        &a \triangle b = (a \setminus b) \cup (b \setminus a) \\
        &S - \text{индуктивное множество}
        \iff
        \begin{cases}
            \varnothing \in S \\
            \forall s \in S \ s \cup \set{s} \in S
        \end{cases}
    \end{flalign*}

    \section{Теоремы}

    \chapter{Формальные языки}
    \begin{flalign*}
        &a \neq \varnothing \iff a - \text{алфавит} \\
        &a \in A \iff a - \text{символ (буква)} \\
        &f: \underline{n} \rightarrow A \iff f - \text{слово} \\
        &\varepsilon - \text{пустое слово} \\
        &\varepsilon = \varnothing
    \end{flalign*}

    \chapter{Программная инженерия}
    Любую программу можно написать на низкоуровневом
    языке - языке, наиболее приближённом к
    устройству компьютера. Однако, тем не менее,
    разрабатывают всё новые языки программирования.
    Далее рассматриваются причины, по которым
    возникает нужда в высокоуровневых языках.

    \section{Изменяемость}
    Программистам в течение жизненного цикла
    разработки ПО приходится изменять программу.
    По причине изменений требований к продукту
    или для устранения ошибки.

    Чтобы что-то изменить,
    нужно найти всю имплементацию этого чего-то
    в программе. C этим возникают две
    трудности: имплементация этого чего-то
    простирается в большой части кода -
    слишком много приходится править, чтобы
    внести нужное изменение -
    и код трудно читаем - сложно понять,
    где то, что нам нужно.

    Языки программирования создают такими,
    чтобы они как можно более полно
    решали данные проблемы.

    Часто добавляют "мультипарадигменные" \
    конструкции, которые должны матчаться в нашем мозгу
    с устоявшимися паттернами. Однако всевозможных
    паттернов настолько много, что данные вводящиеся
    конструкции только капля в море.

    Вторым способом бороться с данными проблемами,
    который работает всегда, является продолжающийся
    рефакторинг согласно сложности Джона.

    \chapter{Трансляторы}
    \textbf{Компилятор} - это программа,
    переводящая текст программы
    с одного языка на другой.

    \textbf{Интерпретатор} - это программа,
    выполняющая код программы,
    не переводя её на другой язык.

    \textbf{Компоновщик (линкер)} - это программа,
    выполняющая разрешение внешних
    адресов памяти, по которым код из одного
    файла может обращаться к информации из другого файла.

    \textbf{Загрузчик} - это программа,
    которая помещает все выполнимые
    объектные файлы в память для
    выполнения.

    Компиляция состоит из анализа и синтеза.

    В течение компиляции код может
    переводиться по цепочке в несколько
    промежуточных представлений.

    Таблица символов содержит в себе информацию,
    которая накапливается на протяжении компиляции.

    \textbf{Проход (pass)} - это этапы компиляции,
    преобразующие один файл в другой
    (необязательно в файл с целевым кодом).

    \section{Этапы компиляции}
    \subsection{Лексический анализ (сканирование)}
    \textbf{Лексема} - это значащая последовательность символов кода.

    \textbf{Токен} - это значение <имя токена, значение атрибута>,
    представляющее лексему, где значение атрибута
    указывает на запись в таблице символов.

    \subsection{Синтаксический анализ (парсинг/разбор)}
    Синтаксический анализатор структурирует токены в синтаксическое дерево.

    \textbf{Контекстно-свободная грамматика (КС-грамматика)}.

    \textbf{Терминальный символ} - это элементарный символ языка,
    определяемый грамматикой.

    \textbf{Нетерминальный символ} - это множество строк терминалов,
    заданное продукцией.

    \textbf{Продукция} - это определение конкретного нетерминального символа.
    Записывается как $ a \rightarrow b $,
    где $ a $ - нетерминал, называемый заголовком
    (левой частью) продукции, $ b $ - последовательность
    (декартово произведение, если про множества)
    нетерминалов и/или (объединение, если про множества) терминалов
    (последовательность может быть пустой, что соответствует пустой строке или
    пустому множеству), называемая телом (правой частью) продукции.

    Контекстно-свободная грамматика имеет четыре компонента:
    \begin{enumerate}
        \item Множество терминальных символов.
        \item Множество нетерминнальных символов.
        \item Множество продукций.
        \item Стартовый нетерминальный символ.
    \end{enumerate}

    Грамматика выводит (порождает) строки, начиная со стартового символа.

    \textbf{Язык} - это множество строк терминалов, определяемые грамматикой.

    \textbf{Синтаксический анализ} - это выяснение для строки терминалов
    способа её вывода из стартового символа грамматики.

    \textbf{Дерево разбора} - это дерево, представляющее
    порождение конкретной строки языка.

    \textbf{Неоднозначная грамматика} - это грамматика,
    имеющая более одного дерева разбора для какой-то строки.

    \textbf{Форма Бэкуса-Наура (BNF)} - это другая форма записи КС грамматики.

    Для любой КС грамматики существует парсер, который требует для разбора
    строки из $ n $ терминалов время, не превышающее $ O\left(n^3\right) $.

    Вручную обычно используют нисходящий разбор.
    Восходящий разбор работает в большем количестве случаем, чем нисходящий,
    поэтому его используют в автоматическом построении парсеров.

    \textbf{Синтаксически управляемая трансляция} - это трансляция,
    выполняемая путём присоединения правил или программных фрагментов
    к продукциям грамматики.

    \textbf{Атрибут} - это некоторая величина, связанная с программной конструкцией.

    \textbf{Синтаксически управляемое определение} связывается:
    \begin{enumerate}
        \item С каждым грамматическим символом множеством атрибутов.
        \item С каждой продукцией множеством семантических правил для
            вычисления значений атрибутов, связанных с символами продукции.
    \end{enumerate}

    \textbf{Простое синтаксически управляемое определение} - это
    синтаксически управляемое определение, в котором атрибуты идут
    в том же порядке, что и соответствующие терминалы и нетерминалы.

    \textbf{Синтезированный атрибут} - это атрибут узла дерева разбора,
    значение которого определяется на основании атрибутов дочерних узлов
    этого узла и атрибутов самого этого узла.

    \textbf{Аннотированное дерево разбора} - это дерево разбора с указанием значений
    атрибутов в каждом узле.

    \textbf{(Синтаксически управляемая) схема трансляции} - это запись присоединённых
    к продукциям грамматики программных фрагментов.

    \subsection{Семантический анализ}
    Семантический анализатор проверяет синтаксическое дерево на корректность.

    \subsection{Генерация промежуточного кода}
    Генерация кода для абстрактной вычислительной машины.

    \subsection{Оптимизация кода}
    Оптимизация промежуточного кода.

    \subsection{Генерация кода}
    Генерация кода на целевом языке.

    \chapter{Необработанное}
    \textbf{Автонимный способ обозначения} - это
    способ обозначения,
    при котором формальные выражения обозначаются так же,
    как и их значения.

    \textbf{Высказывательная форма}.

    \textbf{Именная форма} - это
    выражение с переменной.

    \textbf{Связанные переменные} - это
    переменные, вместо которых
    нельзя подставить значение.

    \textbf{Основания математики} - это
    раздел (в книге сказано "аспект")
    математической логики,
    изучающий объекты математики,
    истинные свойства этих объектов,
    на основании которых можно вести рассуждения,
    а также "сохраняющие истину"{ }способы рассуждений.
\end{document}
